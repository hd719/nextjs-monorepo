# PRD: Go Barcode Lookup Service

> **Status:** In Progress
> **Priority:** High
> **Effort:** Medium (3-5 days)
> **Dependencies:** OpenFoodFacts API, Postgres, TS server functions

---

## Problem Statement

Barcode-based food logging needs a fast, reliable backend that can normalize
nutrition data and persist it for reuse. The main app is TypeScript-based, but
we want a small Go microservice for learning and to keep external API logic
isolated.

**Goal:** Provide a Go service that accepts a barcode, fetches nutrition data
from OpenFoodFacts (with room for future fallbacks), normalizes the response,
saves it to Postgres, and returns a clean, consistent payload to the frontend.

---

## Goals

### Must Have

- [x] `GET /v1/barcodes/{code}` endpoint
- [x] Normalize OpenFoodFacts fields into a stable response
- [x] Persist results in Postgres for reuse
- [x] Return `404` when product not found
- [x] Return `502` when upstream API fails
- [x] Serve JSON responses with consistent shapes

### Should Have

- [x] Configurable cache TTL (re-fetch if stale)
- [ ] Optional `POST /v1/barcodes/lookup` for clients that prefer POST (deferred; GET only for now)
- [ ] Store raw upstream JSON for debugging
- [x] Basic request logging and structured errors

### Nice to Have

- [ ] Optional fallback to USDA FoodData Central
- [ ] Rate limiting per IP
- [x] Health check endpoint `/healthz`

### Non-Goals

- Building a full food database
- Barcode generation
- Generating request IDs (provided by TS server function for distributed tracing)

---

## User Stories

### As a user logging food

- I want to scan a barcode and get nutrition results in under 2 seconds
- I want to see consistent nutrition fields across all products

### As a developer

- I want a single API endpoint that always returns the same shape
- I want cached results so repeat scans are fast
- I want to log raw upstream responses for debugging

---

## Technical Architecture

### Service Stack

| Component | Technology |
|----------|------------|
| HTTP Router | `gin` |
| DB Driver | `pgx` |
| DB | Postgres |
| External API | OpenFoodFacts |

### Integration Flow

```
Client (TS) → Server Function → Go API → OpenFoodFacts
                                 ↓
                              Postgres
```

---

## API Design

### GET /v1/barcodes/{code}

**Required Request Headers (from TS Server Function):**

| Header | Description |
|--------|-------------|
| `X-API-Key` | Service-to-service authentication key (validate against `BARCODE_SERVICE_API_KEY`) |
| `Cookie` | Session cookie containing session token (validate against DB) |
| `X-User-ID` | User ID for auditing/logging (already verified by TS server) |
| `X-Request-ID` | Request ID for distributed tracing (generated by TS server function) |

**Contract details:**

- `Content-Type: application/json` for both success and error responses.
- Echo the `X-Request-ID` header in the response (do NOT generate a new one).
- Success responses always use the documented JSON shape; error responses
  always use the shared error envelope so clients can parse predictably.

**Response (200):**

```json
{
  "id": "0123456789012",
  "barcode": "0123456789012",
  "name": "Oat Milk",
  "brand": "Brand Co",
  "servingSize": "240ml",
  "nutrients": {
    "caloriesKcal": 120,
    "proteinG": 3,
    "carbsG": 16,
    "fatG": 5,
    "fiberG": 2,
    "sugarsG": 7,
    "sodiumG": 90
  },
  "imageUrl": "https://...",
}
```

**Units and normalization:**

- Nutrient values in the API response are **per 100g** to match the existing `FoodItem` schema and diary math in the Healthmetrics app.
- `servingSize` is a UI default; per-serving math (and any rounding/precision for display) is handled on the **frontend**.
- If the upstream API only provides per-serving values, the frontend will handle conversion (the Go service does not convert per-serving to per-100g).
- Optional nutrients (`fiberG`, `sugarG`, `sodiumG`) may be `null` when upstream data is missing; the frontend should display `N/A`.

**Errors:**

- `404` product not found
- `502` upstream error
- `400` invalid barcode

**Error response shape:**

```json
{
  "error": {
    "code": "INVALID_BARCODE",
    "message": "Barcode must be 8-14 digits"
  }
}
```

The `X-Request-ID` value is echoed in the response header for tracing (header-only).

Error codes to use consistently:

- `INVALID_BARCODE` (400)
- `NOT_FOUND` (404)
- `UPSTREAM_ERROR` (502)
- `INTERNAL_ERROR` (500)

---

## Data Model (Postgres)

Healthmetrics already has a shared nutrition model in
`apps/healthmetrics/prisma/schema.prisma` (`FoodItem` mapped to `food_items`).
This service should align with that schema instead of creating a new table.

Key fields to align with:

- `barcode` (unique)
- `serving_size_g`, `serving_size_unit`
- `calories_per_100g`, `protein_g`, `carbs_g`, `fat_g`, `fiber_g`, `sugar_g`, `sodium_mg`

---

## Caching Strategy

- Use Postgres as the cache source of truth.
- Configurable TTL (default 7 days).
- If `updated_at` is newer than TTL, return cached data without
  calling OpenFoodFacts.
- If a barcode exists but is stale, refresh from upstream and upsert
  the record in-place (same barcode).

### Cache-First Lookup Flow

The Go service uses a **cache-first pattern** to minimize external API calls
and reduce latency for repeat scans:

```
┌──────────────┐
│ Validate     │
│ barcode      │
└──────┬───────┘
       │
       ▼
┌──────────────┐     ┌─────────────────────────────────┐
│ Query        │────▶│ Found & fresh? Return cached    │
│ food_items   │     │ data immediately (skip OFF)     │
└──────┬───────┘     └─────────────────────────────────┘
       │ miss or stale
       ▼
┌──────────────┐
│ Call         │
│ OpenFood-    │
│ Facts API    │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│ Upsert to    │
│ food_items   │
└──────┬───────┘
       │
       ▼
┌──────────────────────────────────────────────────────┐
│ Return FoodItem directly from the same response      │
│ (no separate DB query — data is already in memory)   │
└──────────────────────────────────────────────────────┘
```

**Key points:**
- The Go service returns the `FoodItem` data directly in its HTTP response.
- The TS server function does NOT query `food_items` separately — the Go service
  already has the data (either from cache or freshly fetched).
- This avoids an unnecessary round-trip and keeps latency low.
- Cache hits should respond in < 100ms; cache misses depend on OpenFoodFacts latency.

---

## Validation Rules

- Barcode must be digits only and 8-14 characters.
- Reject empty or malformed codes with `400`.
- **Frontend** should validate early for fast user feedback (camera/manual entry).
- **Backend** must enforce validation as the source of truth, since clients can be bypassed.
- Validate barcode checksum for EAN/UPC formats where possible; return `400`
  with `INVALID_BARCODE` on checksum failure.

---

## Observability

### Logs

- Request ID (from `X-Request-ID` header), endpoint, barcode, user ID, status code, duration
- Upstream errors logged with status and body snippet (deferred; requires custom client)
- Use Gin middleware for baseline request logs.
- Use the request ID from the `X-Request-ID` header to correlate logs across TS and Go services.
- **Do NOT generate a new request ID** — always use the one provided by the TS server function.

### Metrics (optional)

- Cache hit rate
- Upstream latency
- Error rates by status code

---

## Security & Authentication

### Authentication Flow

The Go service receives authenticated requests from the TS server function (not directly from browsers):

```
┌─────────────┐    ┌──────────────────┐    ┌──────────────┐
│  Frontend   │ →  │ TS Server Fn     │ →  │ Go Service   │
│ (Browser)   │    │ (validates user) │    │ (validates)  │
└─────────────┘    └──────────────────┘    └──────────────┘
                           │                      │
                           │ Sends:               │ Validates:
                           │ • X-API-Key          │ • API key matches env
                           │ • Cookie (session)   │ • Session token valid in DB
                           │ • X-User-ID          │ • Logs user ID
                           │ • X-Request-ID       │ • Echoes request ID
```

### Authentication Middleware (Must Implement)

The Go service must validate incoming requests:

1. **Validate API Key** (required)
   - Check `X-API-Key` header matches `BARCODE_SERVICE_API_KEY` env var
   - Return `401 Unauthorized` if missing or invalid

2. **Validate Session** (required)
   - Extract session token from `Cookie` header (Better Auth session cookie)
   - Validate session in DB (`session` table) by token
   - Return `401 Unauthorized` if missing or expired

3. **Extract User Context** (for logging)
   - Read `X-User-ID` header for audit logs
   - Read `X-Request-ID` header for distributed tracing

### Environment Variables for Auth

| Variable | Required | Description |
|----------|----------|-------------|
| `BARCODE_SERVICE_API_KEY` | Yes | Shared secret with TS app (min 32 chars) |
| `BETTER_AUTH_COOKIE_NAME` | Yes | Session cookie name carrying the session token |

### General Security

- No PII stored (only barcode and nutrition data)
- Upstream API (OpenFoodFacts) called server-side only
- Service should only be reachable server-to-server (private network/service mesh)
- Rate limiting per user ID (using `X-User-ID` header)
- Rate limiter is in-memory per service instance; inactive user buckets are evicted (TTL 30m, sweep every 5m)

### Public Exposure Checklist (if ever needed)

- All auth checks above are mandatory (API key + session validation)
- Do not rely on `Origin` or `Referer` headers for security (they can be spoofed)
- Configure CORS only if browsers will call the service directly
- Add stricter rate limits and abuse detection
- Enforce TLS and rotate credentials/keys

### CORS vs Authentication (Reminder)

- CORS is a browser enforcement mechanism; it does not secure your API.
- `Origin`/`Referer` headers are not trustworthy for access control.
- Real security comes from API key + session validation.

---

## Versioning

- All public routes are versioned under `/v1`.
- Backward-incompatible changes require a new version prefix (e.g. `/v2`).

---

## Config

Required environment variables:

### Authentication (Required)

- `BARCODE_SERVICE_API_KEY` — Shared secret with TS app (min 32 chars)
- `BETTER_AUTH_COOKIE_NAME` — Session cookie name carrying the session token

### Database

- `DATABASE_URL` — Postgres connection string

### OpenFoodFacts

- `OPENFOODFACTS_TIMEOUT` (default `5s`)
- `OPENFOODFACTS_USER_AGENT` (optional; uses library default if empty)
- `OPENFOODFACTS_BASE_URL` (optional; if it contains `openfoodfacts.net`, use sandbox mode)
- `OPENFOODFACTS_RETRY_MAX_ATTEMPTS` (default 3)
- `OPENFOODFACTS_RETRY_BASE_DELAY` (default `200ms`)
- `OPENFOODFACTS_RETRY_MAX_DELAY` (default `2s`)

### Caching

- `BARCODE_CACHE_TTL_DAYS` (default 7)

### Observability

- `LOG_LEVEL` (default `info`)

### Rate Limiting

- `RATE_LIMIT_CAPACITY` (default 10)
- `RATE_LIMIT_REFILL_RATE` (default 1 token/sec)

---

## Upstream Timeouts and Retries (Pseudo-code)

```
function fetchFromOpenFoodFacts(barcode):
  attempts = 0
  maxAttempts = OPENFOODFACTS_RETRY_MAX_ATTEMPTS
  baseDelay = OPENFOODFACTS_RETRY_BASE_DELAY
  maxDelay = OPENFOODFACTS_RETRY_MAX_DELAY

  while attempts < maxAttempts:
    attempts += 1
    response, err = httpGetWithTimeout(OPENFOODFACTS_TIMEOUT)

    if err is ErrNoProduct or response.body indicates "product not found":
      return not_found(404) // do not retry

    if err is timeout or network_error or response.status >= 500:
      if attempts == maxAttempts:
        return upstream_error(502)
      sleep(min(baseDelay * 2^(attempts-1), maxDelay))
      continue

    return response.data
```

Surface partial failures as `502` with `UPSTREAM_ERROR` and include the
`X-Request-ID` in logs and response headers. Do not return upstream payloads directly.

---

## Testing (Planned)

- Unit: barcode validation (digits, length)
- Unit: normalization mapping (per-100g conversion, missing fields)
- Integration: mock upstream responses (found, not found, 5xx, timeout)

---

## Rollout Plan

1. Build and deploy Go service in a dev environment.
2. Wire TS server function to call Go API.
3. Add feature flag in the frontend for barcode lookup.
4. Monitor logs and cache hit rate.
5. Roll out to all users.

---

## Open Questions

- Should the service use a separate database or shared cluster?
- Do we need a USDA fallback in v1?
- What TTL is acceptable for cache freshness?
